package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"errors"
	"log"
	"tvapp-backend/database"
	"tvapp-backend/graph/model"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// CreateNews is the resolver for the createNews field.
func (r *mutationResolver) CreateNews(ctx context.Context, title string, content string, authorName string, authorEmail string) (*model.News, error) {
	collection := database.Client.Database("tvapp_db").Collection("news")

	// Create a new news object
	news := model.News{
		ID:      primitive.NewObjectID().Hex(),
		Title:   title,
		Content: content,
		Author: &model.Author{
			Name:  authorName,
			Email: authorEmail,
		},
	}

	// Insert into MongoDB
	_, err := collection.InsertOne(ctx, news)
	if err != nil {
		return nil, err
	}

	return &news, nil
}

// UpdateNews is the resolver for the updateNews field.
func (r *mutationResolver) UpdateNews(ctx context.Context, id string, title *string, content *string, authorName *string, authorEmail *string) (*model.News, error) {
	collection := database.Client.Database("tvapp_db").Collection("news")

	// Convert id from string to ObjectId
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, errors.New("invalid id format")
	}
	// Prepare the fields to update
	updateFields := bson.M{}
	if title != nil {
		updateFields["title"] = *title
	}
	if content != nil {
		updateFields["content"] = *content
	}
	if authorName != nil || authorEmail != nil {
		updateFields["author"] = bson.M{}
		if authorName != nil {
			updateFields["author"].(bson.M)["name"] = *authorName
		}
		if authorEmail != nil {
			updateFields["author"].(bson.M)["email"] = *authorEmail
		}
	}

	log.Printf("%s id", id)
	// Update the document in MongoDB
	filter := bson.M{"_id": objectID}
	update := bson.M{"$set": updateFields}
	_, err = collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, err
	}

	// Retrieve and return the updated document
	var updatedNews model.News
	err = collection.FindOne(ctx, filter).Decode(&updatedNews)
	if err != nil {
		return nil, err
	}

	return &updatedNews, nil
}

// DeleteNews is the resolver for the deleteNews field.
func (r *mutationResolver) DeleteNews(ctx context.Context, id string) (bool, error) {
	collection := database.Client.Database("tvapp_db").Collection("news")
	// Convert id from string to ObjectId
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return false, errors.New("invalid id format")
	}
	// Delete the document
	filter := bson.M{"_id": objectID}
	result, err := collection.DeleteOne(ctx, filter)
	if err != nil {
		return false, err
	}

	// Check if a document was actually deleted
	return result.DeletedCount > 0, nil
}

// GetNews retrieves all news from the MongoDB collection
func (r *queryResolver) GetNews(ctx context.Context) ([]*model.News, error) {
	// MongoDB collection
	collection := database.Client.Database("tvapp_db").Collection("news")

	// Query the database
	cursor, err := collection.Find(ctx, bson.M{}) // bson.M{} means "find all documents"
	if err != nil {
		log.Printf("Failed to query news: %v", err)
		return nil, err
	}
	defer cursor.Close(ctx)

	// Decode results
	var news []*model.News
	for cursor.Next(ctx) {
		var n model.News
		if err := cursor.Decode(&n); err != nil {
			log.Printf("Failed to decode news: %v", err)
			return nil, err
		}
		news = append(news, &n)
	}

	// Handle cursor errors
	if err := cursor.Err(); err != nil {
		log.Printf("Cursor error: %v", err)
		return nil, err
	}

	return news, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
